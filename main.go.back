package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/binary"
	"fmt"
	"net"
	"time"

	"gitea.com/abgr/aerr"
	"golang.org/x/crypto/nacl/box"
)

var cipher16 cipher.Block

func init() {
	var err error
	aesKey := make([]byte, 16)
	cipher16, err = aes.NewCipher(aesKey)
	aerr.Panicerr(err, nil)
}


var myPublicKey *[32]byte
var mySecretKey *[32]byte

type bytes4 = []byte
type bytes32 = []byte

func init() {
	var err error
	myPublicKey, mySecretKey, err = box.GenerateKey(rand.Reader)
	aerr.Panicerr(err, nil)
}

func main() {
	udp, err := net.ListenUDP("udp4", &net.UDPAddr{IP: []byte{0, 0, 0, 0}, Port: 0})
	aerr.Panicerr(err, nil)
	defer udp.Close()
	buff := make([]byte, 1500)
	id := [4]byte{1, 3, 2, 2}
	udp.WriteToUDP(packPing(id[:], myPublicKey[:], []byte{0}), &net.UDPAddr{IP: []byte{45, 92, 94, 151}, Port: 80})
	n, _, err := udp.ReadFromUDP(buff)
	aerr.Panicerr(err, nil)
	_, peerPk, sealedAddr, _ := unpackPong(buff[:n])
	addr, ok := unseal(sealedAddr, peerPk, mySecretKey[:])
	aerr.Assert(ok, "auth failed")
	// fmt.Println(id2, addr, ex)
	now := time.Now()
	for range [100]struct{}{} {
		udp.WriteToUDP(packSend(addr, []byte("hi")),
			&net.UDPAddr{IP: []byte{45, 92, 94, 151}, Port: 80})
		n, _, err = udp.ReadFromUDP(buff)
		aerr.Panicerr(err, nil)
		from, _ := unpackRecv(buff[:n])
		if !bytes.Equal(from, addr) {
			panic("failed")
		}
	}
	fmt.Println(time.Since(now))

}
func routePacket(fromIP []byte, fromPort int, recvData []byte) (toIP []byte, toPort int, sendData []byte) {
	switch recvData[0] & 0b11100000 {
	case ping: //ping
		id, peerPk, extra := unpackPing(recvData)
		if !auth(fromIP, fromPort, extra) {
			panic("auth failed")
		}
		sealedAddr := seal(encodeAddr(fromPort, fromIP), peerPk, mySecretKey[:])
		sendData = packPong(id, myPublicKey[:], sealedAddr, extra)
		toIP = fromIP
		toPort = fromPort
		return
	case send: //send
		toAddr, data := unpackSend(recvData)
		toIP, toPort = decodeAddr(toAddr)
		sendData = packRecv(encodeAddr(fromPort, fromIP), data)
		return
	default:
		panic("invalid packet")
	}
}

const (
	ping uint8 = 0b100_00000
	pong uint8 = 0b110_00000
	send uint8 = 0b101_00000
	recv uint8 = 0b111_00000
)

func auth(fromIP []byte, fromPort int, data []byte) bool {
	return true
}

// func encodePingPacket(fromIP []byte, fromPort int, data []byte) {
// 	len := data[0] & 0b00011111
// 	if len != 0 {
// 		return
// 	}
// 	//id := data[1 : 1+8]
// 	peerPublicKey := data[1+8 : 1+8+32]
// 	token := data[1+8+32:]
// 	if !auth(fromIP, fromPort, token) {
// 		return
// 	}
// 	addr := seal(encodeAddr(fromPort, fromIP), peerPublicKey, mySecretKey[:])

// }
func packRecv(from, data []byte) []byte {
	buff := make([]byte, 1+len(from)+len(data))
	buff[0] = uint8(len(from)) - 1 | send
	copy(buff[1:1+len(from)], from)
	copy(buff[1+len(from):], data)
	return buff
}
func unpackRecv(pack []byte) (from, data []byte) {
	lenAddr := (pack[0] & 0b000_11111) + 1
	from = pack[1 : lenAddr+1]
	data = pack[1+lenAddr:]
	return
}
func packSend(to, data []byte) []byte {
	buff := make([]byte, 1+len(to)+len(data))
	buff[0] = uint8(len(to)) - 1 | send
	copy(buff[1:1+len(to)], to)
	copy(buff[1+len(to):], data)
	return buff
}
func unpackSend(pack []byte) (to, data []byte) {
	lenAddr := (pack[0] & 0b000_11111) + 1
	to = pack[1 : lenAddr+1]
	data = pack[1+lenAddr:]
	return
}

func packPong(id bytes4, myPk bytes32, sealedAddr, extra []byte) []byte {
	buff := make([]byte, 1+4+32+1+len(sealedAddr)+len(extra))
	buff[0] = pong
	copy(buff[1:1+4], id)
	copy(buff[1+4:1+4+32], myPk)
	buff[1+4+32] = uint8(len(sealedAddr))
	copy(buff[1+4+32+1:1+4+32+1+len(sealedAddr)], sealedAddr)
	copy(buff[1+4+32+1+len(sealedAddr):], extra)
	return buff
}
func unpackPong(pack []byte) (id bytes4, peerPk bytes32, sealedAddr, extra []byte) {
	id = pack[1 : 1+4]
	peerPk = pack[1+4 : 1+4+32]
	lenSealedAddr := pack[1+4+32]
	sealedAddr = pack[1+4+32+1 : 1+4+32+1+lenSealedAddr]
	extra = pack[1+4+32+1+lenSealedAddr:]
	return
}
func packPing(id bytes4, myPk bytes32, extra []byte) []byte {
	buff := make([]byte, 1+4+32+len(extra))
	buff[0] = ping
	copy(buff[1:1+4], id)
	copy(buff[1+4:1+4+32], myPk)
	copy(buff[1+4+32:], extra)
	return buff
}
func unpackPing(pack []byte) (id bytes4, peerPk bytes32, extra []byte) {
	id = pack[1 : 1+4]
	peerPk = pack[1+4 : 1+4+32]
	extra = pack[1+4+32:]
	return
}
func seal(raw []byte, peerPublic, mySeret bytes32) []byte {
	var sk, pk [32]byte
	var nonce [24]byte
	rand.Read(nonce[:])
	copy(peerPublic, pk[:])
	copy(mySeret, sk[:])
	return box.Seal(nonce[:], raw, &nonce, &pk, &sk)
}
func unseal(sealed []byte, peerPublic, mySeret bytes32) ([]byte, bool) {
	var sk, pk [32]byte
	var nonce [24]byte
	rand.Read(nonce[:])
	copy(peerPublic, pk[:])
	copy(mySeret, sk[:])
	copy(nonce[:], sealed[:24])
	return box.Open(nil, sealed[24:], &nonce, &pk, &sk)
}
